import { StyleSheet } from "react-native";import moment from "moment";import {  Categories,  TItem,  TTransaction,} from "features/transactions/Transactions.types";import { getDenomination } from "features/transactions/Tansactions.utils";import {  TChartTiming,} from "features/analytics/Analytics.types";import { TBalance, TMoneyFlow } from "src/types";interface ObjectWithId {  id: number;}export const uniqueId = (array: ObjectWithId[]): number => {  if (!array?.length) return 0;  return array?.at(-1).id + 1;};export const toNormalCase = (text: string): string => {  return text    .split("")    .map((char) => {      if (/_/.test(char)) return " ";      if (/[A-Z]/.test(char)) return " " + char;      return char;    })    .join("");};export const capitalize = (text: string, onlyFirst: boolean = true): string =>  onlyFirst    ? text[0].toUpperCase() + text.slice(1)    : text        .split(" ")        .map((subtext) => subtext[0].toUpperCase() + subtext.slice(1))        .join(" ");export const createArray = (  length: number,  from: number = 0,  step = 1): number[] => {  const array = [];  for (let i = 0; i < length; i++) {    array[i] = step * i + from;  }  return array;};export const daysPast = (from: Date, to: Date): number =>  (from.getTime() - to.getTime()) / 1000 / 60 / 60 / 24;export const formatMoney = (value: number): string => {  const [integer,decimal] = value.toFixed(2).split('.');  const chars = `${integer}`.split("").reverse();  for (let i = 0; i < chars.length; i += 3) {    chars[i] = chars[i] + " ";  }  chars.reverse();  return chars.join("").trim() + "." + decimal;};export const createStyles = (callback) => (theme) =>  StyleSheet.create(callback(theme));export const arrayOfUniques = (array) => {  let uniqueArray = [];  array.forEach(    (item) => !uniqueArray.includes(item) && uniqueArray.push(item)  );  return uniqueArray;};export const pureDate = (date: Date = new Date()): Date => {  return moment({    date: date.getDate(),    month: date.getMonth(),    year: date.getFullYear(),  }).toDate();};export const clamp = (number: number, min: number, max: number) =>  Math.max(Math.min(number, max), min);export const getDynamics = (  transactions: TTransaction[],  items: TItem[],  by: TChartTiming,  filters?: Record<"wallets" | "incomes" | "expenses", number[]>): {  id: number;  date: Date;  expenses: TMoneyFlow[];  incomes: TMoneyFlow[];}[] => {  const trans = transactions    .map((t) => {      const { fromItemId, toItemId, ...newTransaction } = t;      return {        ...newTransaction,        fromItem: items.find((i) => i.id === fromItemId),        toItem: items.find((i) => i.id === toItemId),      };    })    .filter((t) => {      if (filters === undefined) return true;      if (        !filters.wallets.includes(t.fromItem.id) &&        !filters.wallets.includes(t.toItem.id)      )        return false;      const flatIdsArray = [...filters.expenses, ...filters.incomes];      return (        flatIdsArray.includes(t.fromItem.id) ||        flatIdsArray.includes(t.toItem.id)      );    });  if (!trans.length) return [];  const start = new Date(    Math.min(...trans.map((t) => new Date(t.date).getTime()))  );  const dateUnits = getDateUnits(by);  const dynamics = [];  const datesRange = [];  for (let i = 0; true; i++) {    const nextDate = moment(start).add(i, dateUnits).startOf(dateUnits);    datesRange[0] = nextDate;    datesRange[1] = moment(nextDate).endOf(dateUnits);    if (datesRange[0].isAfter(pureDate())) break;    const transByDate = trans.filter((t) => {      const d = moment(new Date(t.date));      return d.isSameOrAfter(datesRange[0]) && d.isBefore(datesRange[1]);    });    const expenses = reduceAmount(      transByDate        .filter((t) => getDenomination(t.fromItem?.type, t.toItem?.type) === -1)        .map((t) => ({ category: t.toItem.name, amount: t.amount }))    );    const incomes = reduceAmount(      transByDate        .filter((t) => getDenomination(t.fromItem?.type, t.toItem?.type) === 1)        .map((t) => ({ category: t.fromItem.name, amount: t.amount }))    );    dynamics.push({      id: i,      date: datesRange[0].toDate(),      expenses,      incomes,    });  }  return dynamics;};const reduceAmount = (items: TMoneyFlow[]): TMoneyFlow[] => {  const categories = arrayOfUniques(items.map((i) => i.category));  return categories.map((c) => ({    category: c,    amount: items      .filter((i) => i.category === c)      .map((i) => i.amount)      .reduce((acc, num) => acc + num, 0),  }));};export const getDateUnits = (by: TChartTiming) => {  switch (by) {    case "years":      return "year";    case "months":      return "month";    case "weeks":      return "week";    case "days":      return "day";  }};export const weekOfMonth = (date) => {  const firstDayOfMonth = moment(date).clone().startOf("month");  const firstDayOfWeek = firstDayOfMonth.clone().startOf("week");  const offset = firstDayOfMonth.diff(firstDayOfWeek, "days");  return Math.floor((moment(date).date() + offset) / 7);};export const getBalance = (  transactions: TTransaction[],  items: TItem[]): { wallets: TBalance[]; totalBalance: number } => {  const boundedTransactions = transactions.map((t) => ({    ...t,    fromItem: items.find((i) => i.id === t.fromItemId),    toItem: items.find((i) => i.id === t.toItemId),  }));  const wallets: TBalance[] = items    .filter((i) => i?.type === Categories.wallet)    .map((i) => ({ itemId: i.id, name: i.name, balance: i.initialBalance }));  const newWallets = wallets.map((wallet) => {    const total = boundedTransactions      .filter(        (t) => t.toItemId === wallet.itemId || t.fromItemId === wallet.itemId      )      .reduce((balance, transaction) => {        const { fromItem, toItem } = transaction;        switch (getDenomination(fromItem?.type, toItem?.type)) {          case -1:            return balance - transaction.amount;          case 0:            if (fromItem.id === wallet.itemId)              return balance - transaction.amount;            if (toItem.id === wallet.itemId)              return balance + transaction.amount;            break          case 1:            return balance + transaction.amount;        }      }, wallet.balance);    return { ...wallet, balance: total };  });  return {    wallets: newWallets,    totalBalance: newWallets.reduce((acc, { balance }) => acc + balance, 0),  };};export const median = arr => {  if(!arr.length) return 0  const mid = Math.floor(arr.length / 2),    nums = [...arr].sort((a, b) => a - b);  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;};