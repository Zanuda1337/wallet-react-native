import { TDynamic, TMoneyFlow } from "src/types";import { median } from "src/utils";import { TItem } from "features/transactions/Transactions.types";const compose = (  dynamics: TDynamic[],  items,  category: "expenses" | "incomes"): { category: string; operations: number[] }[] => {  let result: { category: string; operations: number[] }[] = [];  dynamics.forEach((value) => {    const flows: TMoneyFlow[] = items      .filter((i) => i.type === category.slice(0, category.length-1))      .map((i) => {        const item = value[category].find((e) => e.category === i.name);        if (item) return { category: i.name, amount: item.amount };        return { category: i.name, amount: 0 };      });    flows.forEach((moneyFlow) => {      const currentFlow = result.find(        (spend) => spend.category === moneyFlow.category      );      if (!currentFlow)        result.push({          category: moneyFlow.category,          operations: [moneyFlow.amount],        });      else {        result[result.indexOf(currentFlow)].operations.push(          moneyFlow.amount        );      }    });  });  return result;};export const getAverageCashFlow = (dynamics: TDynamic[], items: TItem[]) => {  const spending: { category: string; operations: number[] }[] = compose(dynamics, items, 'expenses');  const gain: { category: string; operations: number[] }[] = compose(dynamics, items, 'incomes')  return {    expense: spending      .map((spend) => ({        category: spend.category,        median: median(spend.operations),        average:          spend.operations.reduce((acc, value) => acc + value, 0) /          spend.operations.length,      }))      .sort((a, b) => b.average - a.average),    income: gain      .map((spend) => ({        category: spend.category,        median: median(spend.operations),        average:          spend.operations.reduce((acc, value) => acc + value, 0) /          spend.operations.length,      }))      .sort((a, b) => b.average - a.average),  };};