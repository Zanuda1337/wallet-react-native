import { TDynamic, TMoneyFlow } from "src/types";import { median } from "src/utils";import { TItem } from "features/transactions/Transactions.types";const compose = (  dynamics: TDynamic[],  items,  category: "expenses" | "incomes"): { category: string; operations: number[] }[] => {  let result: { category: string; operations: number[] }[] = [];  dynamics.forEach((value) => {    const flows: TMoneyFlow[] = items      .filter((i) => i.type === category.slice(0, category.length - 1))      .map((i) => {        const item = value[category].find((e) => e.category === i.name);        if (item) return { category: i.name, amount: item.amount };        return { category: i.name, amount: 0 };      });    flows.forEach((moneyFlow) => {      const currentFlow = result.find(        (spend) => spend.category === moneyFlow.category      );      if (!currentFlow)        result.push({          category: moneyFlow.category,          operations: [moneyFlow.amount],        });      else {        result[result.indexOf(currentFlow)].operations.push(moneyFlow.amount);      }    });  });  return result;};export const getAverageCashFlow = (dynamics: TDynamic[], items: TItem[]) => {  const spending: { category: string; operations: number[] }[] = compose(    dynamics,    items,    "expenses"  );  const gain: { category: string; operations: number[] }[] = compose(    dynamics,    items,    "incomes"  );  return {    expense: spending      .map((spend) => {        const spendOperations = [...spend.operations].slice(0, -1);        return {          category: spend.category,          median: median(spendOperations),          average:            spendOperations.reduce((acc, value) => acc + value, 0) /            spendOperations.length,        };      })      .sort((a, b) => b.average - a.average),    income: gain      .map((income) => {        const incomeOperations = [...income.operations].slice(0, -1);        return {          category: income.category,          median: median(incomeOperations),          average:            incomeOperations.reduce((acc, value) => acc + value, 0) /            incomeOperations.length,        };      })      .sort((a, b) => b.average - a.average),  };};