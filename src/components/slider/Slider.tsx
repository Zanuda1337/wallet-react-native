import React, { useEffect, useMemo, useRef, useState } from "react";import {  Animated,  Dimensions,  LayoutRectangle,  PanResponder,  View,  Text,} from "react-native";import { useStyles, useTheme } from "src/hooks";import { sliderStyles } from "src/components/slider/style";import { clamp } from "src/utils";type TSliderProps = {  range?: boolean;  thumbDiameter?: number;  max?: number;  min?: number;  step?: number;  value: number | [number, number];  onChange: (value: number | [number, number]) => void;};const trackHeight = 4;const toPanData = (  value: number,  trackWidth: number,  max: number,  min: number) => (trackWidth / (max - min)) * (value - min);const normalizeData = (  value: number,  trackWidth: number,  max: number,  min: number) => ((max - min) / (trackWidth || 1)) * value + min;const Slider: React.FC<TSliderProps> = ({  range,  thumbDiameter = 23,  max = 100,  min = 0,  step = 1,  value,  onChange,}) => {  const style = useStyles(sliderStyles);  const theme = useTheme();  const thumbRadius = thumbDiameter * 0.5;  const initialPans = [new Animated.ValueXY()];  const initialThumbs: [number] | [number, number] = range    ? [value[0]]    : [value];  if (range) {    initialPans.push(new Animated.ValueXY());    initialThumbs.push(value[1]);  }  const pans = useRef(initialPans).current;  const [thumbsValues, setThumbsValues] = useState<[number] | [number, number]>(    initialThumbs  );  const [dragging, setDragging] = useState<number>();  const [layout, setLayout] = useState<LayoutRectangle>();  const handleChange = (newValue: [number] | [number, number]) => {    if (range) {      onChange(        [...(newValue as [number, number])].map((v) => +v.toFixed(2)) as [          number,          number        ]      );      return;    }    onChange(newValue[0]);  };  useEffect(() => {    if (range) {      setThumbsValues(value as [number, number]);      return;    }    setThumbsValues([value] as [number]);  }, [value, max, min]);  useEffect(() => {    if (!layout?.width) return;    pans.forEach((pan, index) =>      pan.x.setValue(toPanData(thumbsValues[index], trackWidth, max, min))    );  }, [layout]);  const trackWidth = (layout?.width || 0) - thumbDiameter;  const panResponders = useMemo(    () =>      pans.map((pan, index) =>        PanResponder.create({          onStartShouldSetPanResponder: () => max > 0,          onPanResponderMove: (e, gestureState) => {            setDragging(index);            let newThumbsValues = [...thumbsValues];            newThumbsValues[index] = toPanData(              newThumbsValues[index],              trackWidth,              max,              min            );            const offset =              (Dimensions.get("screen").width - layout.width) * 0.5;            newThumbsValues[index] = clamp(              gestureState.moveX - offset - thumbRadius,              0,              layout.width - thumbDiameter            );            pan.x.setValue(newThumbsValues[index]);            newThumbsValues[index] = normalizeData(              newThumbsValues[index],              trackWidth,              max,              min            );            let stepOffset = newThumbsValues[index] % step;            newThumbsValues[index] =              newThumbsValues[index] -              (stepOffset < step / 2 ? +stepOffset : -(step - stepOffset));            newThumbsValues[index] = clamp(newThumbsValues[index], min, max)            newThumbsValues = [...newThumbsValues].sort((a, b) => a - b)            setThumbsValues(newThumbsValues as [number] | [number, number]);            handleChange(newThumbsValues as [number] | [number, number]);          },          onPanResponderRelease: () => {            setDragging(undefined);          },          onPanResponderTerminate: () => setDragging(undefined),        })      ),    [thumbsValues, layout, dragging]  );  return (    <View style={{opacity: max > 0 ? 1 : 0.25}}>      <View        style={[          style.container,          {            marginTop: thumbDiameter + 30,            paddingHorizontal: thumbRadius,            marginBottom: thumbRadius,          },        ]}        onLayout={({ nativeEvent }) => setLayout(nativeEvent.layout)}      >        <View style={[style.track, { height: trackHeight }]} />        {pans.map((pan, index) => (          <Animated.View            key={index}            style={[              style.thumb,              {                transform: [                  {                    translateX:                      toPanData(value[index], trackWidth, max, min) -                      (dragging === index ? style.draggable.borderWidth : 0),                  },                ],                width:                  thumbDiameter +                  (dragging === index ? style.draggable.borderWidth * 2 : 0),                height:                  thumbDiameter +                  (dragging === index ? style.draggable.borderWidth * 2 : 0),                bottom:                  -(thumbRadius - trackHeight / 2) -                  (dragging === index ? style.draggable.borderWidth : 0),              },              dragging === index && style.draggable,            ]}            {...panResponders[index].panHandlers}          />        ))}        {range && (          <View            pointerEvents="none"            style={[              style.highlightedLine,              {                width: Math.abs(                  toPanData(thumbsValues[0], trackWidth, max, min) -                    toPanData(thumbsValues[1], trackWidth, max, min)                ),                left:                  toPanData(                    [...thumbsValues].sort((a, b) => a - b)[0],                    trackWidth,                    max,                    min                  ) + thumbRadius,              },            ]}          />        )}      </View>      {thumbsValues        .filter((v, i) => dragging === i)        .map((value, index) => (          <View            key={index}            style={{              width: 200,              display: "flex",              alignItems: "center",              justifyContent: "center",              bottom: thumbDiameter + 13,              position: "absolute",              left:                clamp(                  toPanData(value, trackWidth, max, min),                  thumbRadius,                  (layout?.width || 0) - thumbDiameter * 2                ) -                100 +                thumbRadius,              height: 30,            }}          >            <View              pointerEvents="none"              style={[                {                  padding: 5,                  backgroundColor: theme.colors.subtext,                  borderRadius: 5,                },              ]}            >              <Text                style={[                  {                    width: "100%",                    textAlign: "center",                    fontFamily: "Inter-SemiBold",                    color: theme.colors.background,                    fontSize: 14,                    opacity: 0.8,                  },                ]}              >                {value.toFixed(2)}              </Text>            </View>          </View>        ))}    </View>  );};export default Slider;