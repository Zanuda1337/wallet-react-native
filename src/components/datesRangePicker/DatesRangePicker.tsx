import React, {  memo,  useCallback,  useEffect,  useMemo,  useRef,  useState,} from "react";import { View, Text, Dimensions, Modal, StatusBar } from "react-native";import moment, {Moment} from "moment";import { capitalize, createArray, pureDate } from "src/utils";import { useStyles, useTheme } from "src/hooks";import { FlashList } from "@shopify/flash-list";import Header from "src/components/header/Header";import Button from "src/components/button/Button";import { datesRangePickerStyles } from "src/components/datesRangePicker/style";import { TDatesRange } from "src/components/datesRangePicker/DatesRangePicker.types";import Month from "src/components/datesRangePicker/month/Month";import { useIntl } from "react-intl";const getDisplayedDates = (  dates: TDatesRange,  formatMessage: ({ id }: { id: string }) => string): [string, string] => {  let from = capitalize(formatMessage({ id: "START_DATE" }));  let to = capitalize(formatMessage({ id: "EXPIRATION_DATE" }));  switch (dates.length) {    case 0:      break;    case 1:    case 2:      from = `${formatMessage({ id: "from" })} ${moment(dates[0]).format(        "DD.MM.YYYY"      )}`;      if (dates[1])        to = `${formatMessage({ id: "to" })} ${moment(dates[1]).format(          "DD.MM.YYYY"        )}`;      break;    default:      break;  }  return [from, to];};const generateDays = (month: number, year: number, momentInstance: typeof moment) => {  const lastDayOfMonth = momentInstance({ month, year }).endOf("month").date();  let firstDay = momentInstance({ month, year }).startOf("month").day();  firstDay = firstDay === 0 ? 7 : firstDay;  const offset = firstDay - 2;  return createArray(lastDayOfMonth + offset + 1, -offset);};const generateCalendar = (momentInstance: typeof moment): TCalendarItem[] => {  const yearsLength = 6;  const months: Moment[] = [];  const firstYear = new Date().getFullYear() - yearsLength + 1;  for (let year = firstYear; year < yearsLength + firstYear; year++) {    for (let month = 0; month < 12; month++) {      months.push(moment({ year, month }));    }  }  return months.map((month) => ({    monthIndex: month.month(),    lastDay: momentInstance(new Date(month.year(), month.month()))      .endOf("month")      .date(),    date: new Date(month.year(), month.month()),    momentDate: momentInstance(new Date(month.year(), month.month())),    days: generateDays(month.month(), month.year(), momentInstance).map((day) => ({      value: day,      momentDate: momentInstance({        date: day,        month: month.month(),        year: month.year(),      }),      date: new Date(month.year(), month.month(), day),      isStartOfWeek:        momentInstance({ date: day, month: month.month(), year: month.year() })          .startOf("week")          .date() === day,      isEndOfWeek:        momentInstance({ date: day, month: month.month(), year: month.year() })          .endOf("week")          .date() === day,      isFuture:        new Date(month.year(), month.month(), day).getTime() >=        new Date().getTime(),    })),  }));};export type TCalendarItem = {  monthIndex: number;  lastDay: number;  date: Date;  momentDate: Moment;  days: {    value: number;    momentDate: Moment;    date: Date;    isFuture: boolean;    isStartOfWeek: boolean;    isEndOfWeek: boolean;  }[];};type TDatesRangePickerProps = {  range: TDatesRange;  visible?: boolean;  onChange: (range: TDatesRange) => void;  onClose?: () => void;};const DatesRangePicker: React.FC<TDatesRangePickerProps> = ({  range,  visible,  onClose,  onChange,}) => {  const theme = useTheme();  const style = useStyles(datesRangePickerStyles);  const [datesRange, setDatesRange] = useState<TDatesRange>(range);  const [loading, setLoading] = useState(true);  const [initialScrollIndex, setInitialScrollIndex] = useState<number>(null);  const listRef = useRef<FlashList<TCalendarItem>>(null);  const { formatMessage } = useIntl();  useEffect(() => {    setDatesRange(range);  }, [range]);  const itemWidth = useMemo(    () =>      (Dimensions.get("screen").width -        theme.styles.container.paddingHorizontal * 2 -        1) /        7 -      style.day.paddingHorizontal * 2,    []  );  const handleChangeRange = useCallback(    async (date: Date) => {      let newRange: TDatesRange = [datesRange[0], date]      if (!datesRange.length || datesRange.length === 2) {        newRange = [date];      }      setDatesRange(newRange.sort((a, b) => a.getTime() - b.getTime()));    },    [datesRange]  );  const handleMonthPress = useCallback((month: Date) => {    let end = pureDate(moment(month).endOf("month").toDate());    end = pureDate().getTime() < end.getTime() ? pureDate() : end;    setDatesRange([month, end]);  }, []);  const calendar: TCalendarItem[] = useMemo(() => generateCalendar(moment), []);  useEffect(() => {    if (!visible || !listRef.current || initialScrollIndex !== null) return;    setLoading(false);    const today = new Date();    const item = calendar.find(      (value) =>        value.date.getFullYear() === today.getFullYear() &&        value.date.getMonth() === today.getMonth()    );    if (!item) return;    const index = calendar.indexOf(item);    setInitialScrollIndex(index);  }, [listRef, visible, initialScrollIndex]);  const handleScrollTo = useCallback(() => {    if (!listRef.current) return;    listRef.current.scrollToIndex({ index: 0 });    const today = new Date();    const item = calendar.find(      (value) =>        value.date.getFullYear() === today.getFullYear() &&        value.date.getMonth() === today.getMonth()    );    if (!item) return;    const index = calendar.indexOf(item);    listRef.current.scrollToIndex({ index });  }, []);  const keyExtractor = useCallback(    (item: TCalendarItem) => item.date.toString(),    []  );  const [from, to] = getDisplayedDates(datesRange, formatMessage);  const renderDate = useCallback(    ({ item: month, index }: { item: TCalendarItem; index: number }) => {      return (        <Month          month={month}          onSelectMonth={handleMonthPress}          onChangeRange={handleChangeRange}          datesRange={datesRange}          itemWidth={itemWidth}          isLast={index === calendar.length - 1}        />      );    },    [datesRange]  );  return (    <Modal statusBarTranslucent visible={visible} onRequestClose={onClose}>      <View        style={[          theme.styles.container,          {            backgroundColor: theme.colors.background,            flex: 1,            paddingTop: StatusBar.currentHeight,            gap: 0,          },        ]}      >        <Header          styles={{ root: { paddingHorizontal: 0, paddingVertical: 0 } }}          label={capitalize(            `${formatMessage({ id: "select" })} ${formatMessage({              id: "period",            })}`          )}          leftButtonProps={{ onPress: onClose }}          rightButtonProps={{ visible: false }}        />        <View style={style.ranges}>          <View style={style.range}>            <Text style={style.text}>{from}</Text>          </View>          <View style={style.range}>            <Text style={style.text}>{to}</Text>          </View>        </View>        <View          style={[            style.days,            {              justifyContent: "space-between",              paddingHorizontal: style.day.padding,              paddingVertical: 5,            },          ]}        >          {moment.weekdaysMin().map((weekday) => (            <Text              key={weekday}              style={[                style.text,                {                  width: itemWidth,                  textAlign: "center",                  textTransform: "uppercase",                  fontSize: 10,                  fontFamily: "Inter-SemiBold",                },              ]}            >              {weekday}            </Text>          ))}        </View>        <FlashList          drawDistance={0}          viewabilityConfig={{            minimumViewTime: 1000,            viewAreaCoveragePercentThreshold: 50,            itemVisiblePercentThreshold: 25,            waitForInteraction: true,          }}          estimatedFirstItemOffset={0}          estimatedItemSize={300}          ref={listRef}          initialScrollIndex={initialScrollIndex}          extraData={datesRange}          data={calendar}          keyExtractor={keyExtractor}          renderItem={renderDate}          refreshing={loading}        />        <View style={style.footer}>          <View style={{ overflow: "hidden", borderRadius: 5 }}>            <Button              text={"today"}              styles={{                root: [                  style.button,                  { backgroundColor: theme.colors.background + "99" },                ],                text: { color: theme.colors.foreground },              }}              onPress={handleScrollTo}              variant="outlined"            />          </View>          <View style={{ overflow: "hidden", borderRadius: 7 }}>            <Button              text="done"              styles={{ root: style.button }}              onPress={() => {                onChange(datesRange);                onClose();              }}            />          </View>        </View>      </View>    </Modal>  );};export default memo(DatesRangePicker);