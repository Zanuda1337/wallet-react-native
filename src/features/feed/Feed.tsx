import React, { useCallback, useState } from "react";import { Text, View } from "react-native";import { useStyles, useTheme } from "src/hooks";import Transaction from "features/feed/transaction/Transaction";import { useAppSelector, useBoundActions } from "src/store/hooks";import { arrayOfUniques, capitalize, pureDate } from "src/utils";import moment from "moment";import { FormattedMessage, useIntl } from "react-intl";import { getTitle } from "./Feed.utils";import { transactionsActions } from "../transactions/Transactions.slice";import { LayoutAnimation } from "react-native";import TransactionModal, {  ITransactionFieldValues,} from "src/components/transactionModal/TransactionModal";import { TTransaction } from "features/transactions/Transactions.types";import { FlashList } from "@shopify/flash-list";import SvgSelector from "src/components/svgSelector/SvgSelector";import Button from "src/components/button/Button";import IconButton from "src/components/iconButton/IconButton";import DatesRangePicker from "src/components/datesRangePicker/DatesRangePicker";import { TDatesRange } from "src/components/datesRangePicker/DatesRangePicker.types";import { feedStyles } from "features/feed/style";const layoutAnimConfig = {  duration: 300,  update: {    type: LayoutAnimation.Types.easeInEaseOut,  },  delete: {    duration: 300,    type: LayoutAnimation.Types.easeInEaseOut,    property: LayoutAnimation.Properties.opacity,  },};const renderButtonLabel = (  dates: TDatesRange,  start: Date,  formatMessage: ({ id }: { id: string }) => string): string => {  if (    dates[0].getTime() <= start.getTime() &&    dates[1].getTime() === pureDate().getTime()  )    return capitalize(formatMessage({ id: "FOR_ALL_TIME" }));  if (    dates[0].getMonth() === dates[1].getMonth() &&    moment(dates[0]).startOf("month").isSame(dates[0]) &&    (moment(dates[1]).endOf("month").startOf("day").isSame(dates[1]) ||      moment(dates[1]).isSame(pureDate()))  )    return capitalize(      `${formatMessage({ id: "only" })} ${moment(dates[0])        .format("MMMM")        .toLowerCase()}`    );  return `${formatMessage({ id: "from" })} ${moment(dates[0]).format(    "DD.MM.YYYY"  )} ${formatMessage({ id: "to" })} ${moment(dates[1]).format("DD.MM.YYYY")}`;};const Feed: React.FC = () => {  const theme = useTheme();  const style = useStyles(feedStyles);  const intl = useIntl();  const transactions = useAppSelector(    (state) => state.transactionsReducer.transactions  );  const items = useAppSelector((state) => state.transactionsReducer.items);  const [isTransaction, setTransaction] = useState(false);  const [range, setRange] = useState<TDatesRange>([]);  const [activeTransaction, setActiveTransaction] =    useState<TTransaction>(undefined);  const transferredItem = items.find(    (item) => activeTransaction?.fromItemId === item.id  );  const acceptedItem = items.find(    (item) => activeTransaction?.toItemId === item.id  );  const start = new Date(    [...transactions]      .sort((a, b) => (moment(new Date(a.date)).isBefore(new Date(b.date)) ? 1 : -1))      .at(-1).date  );  const normalizedRange: [Date, Date] = [    range[0] || start,    range[1] || pureDate(),  ];  const { formatMessage } = useIntl();  const filteredTransactions = transactions.filter(    (t) =>      new Date(t.date).getTime() >= normalizedRange[0].getTime() &&      new Date(t.date).getTime() <= normalizedRange[1].getTime()  );  const dates = arrayOfUniques(filteredTransactions.map((item) => item.date))    .map((date) => ({      date: new Date(date),      transactions: filteredTransactions.filter((transaction) => {        return moment(new Date(transaction.date)).isSame(date);      }),    }))    .sort((a, b) => (moment(new Date(a.date)).isBefore(new Date(b.date)) ? 1 : -1));  const boundActions = useBoundActions(transactionsActions);  const handleDelete = (id: number) => {    boundActions.deleteTransaction(id);    LayoutAnimation.configureNext(layoutAnimConfig);  };  const handleEdit = useCallback(    (data: ITransactionFieldValues) => {      if (!activeTransaction) return;      const transaction: TTransaction = {        ...activeTransaction,        ...data,        date: data.date.toString(),      };      boundActions.editTransaction(transaction);      setTransaction(false);    },    [activeTransaction]  );  const handleChangeRange = (datesRange: TDatesRange) => {    setRange(datesRange);  };  const [isFilterVisible, setFilterVisible] = useState(false);  const keyExtractor = useCallback((item) => item.date.toString(), []);  const renderItem = useCallback(    ({ item }: { item: { date: Date; transactions: TTransaction[] } }) => (      <View style={theme.styles.container}>        <Text style={theme.styles.title}>{getTitle(item.date, intl)}</Text>        {item.transactions          .filter((transaction) => {            return moment(new Date(transaction.date)).isSame(item.date);          })          .map((transaction, index) => {            const fromItem = items.find(              (item) => item.id === transaction.fromItemId            );            const toItem = items.find(              (item) => item.id === transaction.toItemId            );            if (!fromItem || !toItem) return <></>;            return (              <Transaction                key={index}                amount={transaction.amount}                fromItem={fromItem}                toItem={toItem}                disabled={isTransaction}                onDelete={() => handleDelete(transaction.id)}                onEdit={() => {                  setTransaction(true);                  setActiveTransaction(transaction);                }}              />            );          })}      </View>    ),    [transactions, items, isTransaction]  );  return (    <>      <DatesRangePicker        range={range}        visible={isFilterVisible}        onClose={() => setFilterVisible(false)}        onChange={handleChangeRange}      />      <View        style={[          theme.styles.container,          style.flexRow,          { justifyContent: "space-between" },        ]}      >        <View style={[style.flexRow, { gap: 5 }]}>          <Button            translate={false}            text={renderButtonLabel(normalizedRange, start, formatMessage)}            variant="ghost"            styles={{              text: { textTransform: "none", fontFamily: "Inter-Regular" },              root: {                paddingVertical: 5,                paddingHorizontal: 8,                marginLeft: -7,              },            }}            onPress={() => setFilterVisible(true)}          />          {range.length ? (            <IconButton              size={23}              icon={                <SvgSelector                  id="multiply"                  stroke={theme.colors.foreground}                  size={12}                />              }              onPress={() => setTimeout(() =>handleChangeRange([]))}            />          ) : <></>}        </View>        <IconButton          size={40}          icon={            <SvgSelector id="filter" fill={theme.colors.foreground} size={21} />          }        />      </View>      {dates.length > 0 ? (        <FlashList          estimatedItemSize={144}          data={dates}          keyExtractor={keyExtractor}          renderItem={renderItem}        />      ) : (        <View          style={[            theme.styles.container,            {              display: "flex",              flex: 1,              justifyContent: "center",              alignItems: "center",              paddingBottom: 100,            },          ]}        >          <Text            style={[              theme.styles.title,              { textTransform: "none", fontSize: 16 },            ]}          >            <FormattedMessage id="NO_DATA" />          </Text>        </View>      )}      <TransactionModal        visible={isTransaction}        from={transferredItem?.name}        to={acceptedItem?.name}        icon={acceptedItem?.icon}        onHide={() => setActiveTransaction(undefined)}        onSubmit={(data) => handleEdit(data)}        onBackdropPress={() => setTransaction(false)}        initialValues={{          date: new Date(activeTransaction?.date),          amount: activeTransaction?.amount,          note: activeTransaction?.note,        }}        edit      />      <View style={{ marginBottom: 95 }} />    </>  );};export default Feed;