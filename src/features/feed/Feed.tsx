import React, { useCallback,useMemo, useState } from "react";import {  Text,  TextInput,  View,} from "react-native";import { useStyles, useTheme } from "src/hooks";import Transaction from "features/feed/transaction/Transaction";import { useAppSelector, useBoundActions } from "src/store/hooks";import { arrayOfUniques, capitalize, pureDate } from "src/utils";import moment from "moment";import { FormattedMessage, useIntl } from "react-intl";import { getTitle } from "./Feed.utils";import { transactionsActions } from "../transactions/Transactions.slice";import { LayoutAnimation } from "react-native";import TransactionModal, {  ITransactionFieldValues,} from "src/components/transactionModal/TransactionModal";import { TItem, TTransaction } from "features/transactions/Transactions.types";import { FlashList } from "@shopify/flash-list";import SvgSelector from "src/components/svgSelector/SvgSelector";import Button from "src/components/button/Button";import IconButton from "src/components/iconButton/IconButton";import DatesRangePicker from "src/components/datesRangePicker/DatesRangePicker";import { TDatesRange } from "src/components/datesRangePicker/DatesRangePicker.types";import { feedStyles } from "features/feed/style";import FeedFilters from "features/feed/feedFilters/FeedFilters";import { TFeedFilters } from "features/feed/feedFilters/FeedFilters.types";import Chip from "features/feed/chip/Chip";import {DENOMINATIONS} from "features/feed/Feed.consts";import {getDenomination} from "features/transactions/Tansactions.utils";const layoutAnimConfig = {  duration: 300,  update: {    type: LayoutAnimation.Types.easeInEaseOut,  },  delete: {    duration: 300,    type: LayoutAnimation.Types.easeInEaseOut,    property: LayoutAnimation.Properties.opacity,  },};const renderButtonLabel = (  dates: TDatesRange,  start: Date,  formatMessage: ({ id }: { id: string }) => string): string => {  if (    !dates.length ||    (dates[0].getTime() <= start.getTime() &&      dates[1]?.getTime() === pureDate().getTime())  )    return capitalize(formatMessage({ id: "FOR_ALL_TIME" }));  const currYear = new Date().getFullYear();  const isWithinYear =    dates[0].getFullYear() === currYear &&    (dates[1] ? dates[1].getFullYear() === currYear : true);  const format = isWithinYear ? "DD.MM" : "DD.MM.YYYY";  if (dates.length === 1)    return `${formatMessage({ id: "from" })} ${moment(dates[0]).format(      format    )}`;  if (    dates[0].getMonth() === dates[1].getMonth() &&    moment(dates[0]).startOf("month").isSame(dates[0]) &&    (moment(dates[1]).endOf("month").startOf("day").isSame(dates[1]) ||      moment(dates[1]).isSame(pureDate()))  )    return capitalize(      `${formatMessage({ id: "only" })} ${moment(dates[0])        .format("MMMM")        .toLowerCase()}` +        (isWithinYear ? "" : ` ${moment(dates[0]).format("YYYY")}`)    );  return `${formatMessage({ id: "from" })} ${moment(dates[0]).format(    format  )} ${formatMessage({ id: "to" })} ${moment(dates[1]).format(format)}`;};const Feed: React.FC = () => {  const theme = useTheme();  const style = useStyles(feedStyles);  const intl = useIntl();  const transactions = useAppSelector(    (state) => state.transactionsReducer.transactions  );  const items = useAppSelector((state) => state.transactionsReducer.items);  const [isTransaction, setTransaction] = useState(false);  const [range, setRange] = useState<TDatesRange>([    moment(pureDate()).startOf("months").toDate(),    pureDate(),  ]);  const [activeTransaction, setActiveTransaction] =    useState<TTransaction>(undefined);  const [isDateFilterVisible, setDateFilterVisible] = useState(false);  const [isFilterVisible, setFilterVisible] = useState(false);  const [isSearching, setIsSearching] = useState(false);  const [searchInput, setSearchInput] = useState("");  const [query, setQuery] = useState("");  const transferredItem: TItem = useMemo(    () => items.find((item) => activeTransaction?.fromItemId === item.id),    [activeTransaction]  );  const acceptedItem: TItem = useMemo(    () => items.find((item) => activeTransaction?.toItemId === item.id),    [activeTransaction]  );  const start = new Date(    [...transactions]      .sort((a, b) =>        moment(new Date(a.date)).isBefore(new Date(b.date)) ? 1 : -1      )      .at(-1).date  );  const normalizedRange: [Date, Date] = [    range[0] || start,    range[1] || pureDate(),  ];  const { formatMessage } = useIntl();  const max = Math.max(    ...transactions.map((transaction) => transaction.amount),    0  );  const min = Math.min(    ...transactions.map((transaction) => transaction.amount),    max  );  const initialFilters: TFeedFilters = useMemo(    () => ({      disabledDenominations: [],      range: [min, max],    }),    [transactions]  );  const [filters, setFilters] = useState<TFeedFilters>(initialFilters);  const transactionsWithItems = useMemo(() => transactions.map(t => {    const fromItem = items.find(i => i.id === t.fromItemId)    const toItem = items.find(i => i.id === t.toItemId)    return {...t, fromItem, toItem}  }), [transactions, items]);  const filteredTransactions = useMemo(() => transactionsWithItems.filter((t) => {    const datesFilter =      new Date(t.date).getTime() >= normalizedRange[0].getTime() &&      new Date(t.date).getTime() <= normalizedRange[1].getTime();    const denominationsFilter = !filters.disabledDenominations.includes(getDenomination(t.fromItem.type, t.toItem.type));    const amountFilter = t.amount >= filters.range[0] && t.amount <= filters.range[1];    return datesFilter && denominationsFilter && amountFilter;  }), [filters, normalizedRange]);  const dates = useMemo(    () =>      arrayOfUniques(filteredTransactions.map((item) => item.date))        .map((date) => ({          date: new Date(date),          transactions: filteredTransactions.filter((transaction) => {            return moment(new Date(transaction.date)).isSame(date);          }),        }))        .sort((a, b) =>          moment(new Date(a.date)).isBefore(new Date(b.date)) ? 1 : -1        ),    [filteredTransactions, range]  );  const boundActions = useBoundActions(transactionsActions);  const handleDelete = (id: number) => {    boundActions.deleteTransaction(id);    LayoutAnimation.configureNext(layoutAnimConfig);  };  const handleOpenTransaction = useCallback((transaction: TTransaction) => {    setTimeout(() => {      setTransaction(true);      setActiveTransaction(transaction);    }, 300);  }, []);  const handleEdit = useCallback(    (data: ITransactionFieldValues) => {      if (!activeTransaction) return;      const transaction: TTransaction = {        ...activeTransaction,        ...data,        date: data.date.toString(),      };      boundActions.editTransaction(transaction);      setTransaction(false);    },    [activeTransaction]  );  const handleChangeRange = useCallback((datesRange: TDatesRange) => {    setRange(datesRange);  }, []);  const handleCloseFilter = useCallback(() => {    setFilterVisible(false);  }, []);  const handleOpenFilter = useCallback(() => {    setFilterVisible(true);  }, []);  const keyExtractor = useCallback((item) => item.date.toString(), []);  const renderItem = useCallback(    ({ item }: { item: { date: Date; transactions: TTransaction[] } }) => (      <View style={theme.styles.container}>        <Text style={theme.styles.title}>{getTitle(item.date, intl)}</Text>        {item.transactions          .filter((transaction) => {            return moment(new Date(transaction.date)).isSame(item.date);          })          .map((transaction, index) => {            const fromItem = items.find(              (item) => item.id === transaction.fromItemId            );            const toItem = items.find(              (item) => item.id === transaction.toItemId            );            if (!fromItem || !toItem) return <></>;            return (              <Transaction                key={index}                amount={transaction.amount}                fromItem={fromItem}                toItem={toItem}                // disabled={isTransaction}                onDelete={() => handleDelete(transaction.id)}                onEdit={() => handleOpenTransaction(transaction)}              />            );          })}      </View>    ),    [transactions, items]  );  return (    <>      {isFilterVisible && (        <FeedFilters          filters={filters}          initialFilters={initialFilters}          visible={isFilterVisible}          maxAmount={max}          minAmount={min}          onClose={handleCloseFilter}          onSubmit={(data) => {            setFilters(data);          }}        />      )}      <DatesRangePicker        range={range}        visible={isDateFilterVisible}        onClose={() => setDateFilterVisible(false)}        onChange={handleChangeRange}      />      <View style={[theme.styles.container, style.flexRow, style.row]}>        <View style={[style.flexRow, { gap: 5, flex: 3 }]}>          {!isSearching ? (            <>              <Button                translate={false}                text={renderButtonLabel(range, start, formatMessage)}                variant="ghost"                styles={{                  text: { textTransform: "none", fontFamily: "Inter-Regular" },                  root: {                    paddingVertical: 5,                    paddingHorizontal: 8,                    marginLeft: -7,                  },                }}                onPress={() => setDateFilterVisible(true)}              />              {range.length ? (                <IconButton                  size={23}                  icon={                    <SvgSelector                      id="multiply"                      stroke={theme.colors.foreground}                      size={12}                    />                  }                  onPress={() => setTimeout(() => handleChangeRange([]))}                />              ) : (                <></>              )}            </>          ) : (            <TextInput              placeholder="Search by note..."              placeholderTextColor={theme.colors.subtext}              style={[theme.styles.dialogueText, { flex: 1 }]}              value={searchInput}              onChangeText={(text) => setSearchInput(text)}            />          )}        </View>        <View          style={[            style.flexRow,            { gap: 8, flex: 1, justifyContent: "flex-end" },          ]}        >          {isSearching || (            <IconButton              size={40}              variant="ghost"              styles={{ root: { opacity: 0.33 } }}              icon={                <SvgSelector                  id="filter"                  fill={theme.colors.foreground}                  size={30}                />              }              onPress={handleOpenFilter}            />          )}          <IconButton            size={40}            variant="ghost"            icon={              <SvgSelector                id={isSearching ? "checkmark" : "search"}                fill={theme.colors.foreground}                size={30}              />            }            onPress={() => {              if (isSearching) {                setIsSearching(false);                setQuery(searchInput);                return;              }              setIsSearching(true);            }}          />        </View>      </View>      <View style={[theme.styles.container, style.flexWrap]}>        {query && (          <Chip            isActive            title={query}            onPress={() => {              setQuery("");              setSearchInput("");            }}          />        )}        {filters.disabledDenominations.map((d =>            <Chip              key={d}              isActive              title={formatMessage({id:DENOMINATIONS[d]})}              onPress={() => {                setFilters({...filters, disabledDenominations: filters.disabledDenominations.filter(den => d !== den) })              }}            />        ))}        {JSON.stringify(filters.range) !==          JSON.stringify(initialFilters.range) && (          <Chip            isActive            title={`${filters.range[0]} - ${filters.range[1]}`}            onPress={() => {              setFilters({...filters, range: [min, max]})            }}          />        )}      </View>      {dates.length > 0 ? (        <FlashList          estimatedItemSize={144}          data={dates}          keyExtractor={keyExtractor}          renderItem={renderItem}        />      ) : (        <View          style={[            theme.styles.container,            {              display: "flex",              flex: 1,              justifyContent: "center",              alignItems: "center",              paddingBottom: 100,            },          ]}        >          <Text            style={[              theme.styles.title,              { textTransform: "none", fontSize: 16 },            ]}          >            <FormattedMessage id="NO_DATA" />          </Text>        </View>      )}      <TransactionModal        visible={isTransaction}        from={transferredItem?.name}        to={acceptedItem?.name}        icon={acceptedItem?.icon}        onHide={() => setActiveTransaction(undefined)}        onSubmit={(data) => handleEdit(data)}        onBackdropPress={() => setTransaction(false)}        initialValues={{          date: new Date(activeTransaction?.date),          amount: activeTransaction?.amount,          note: activeTransaction?.note,        }}        edit      />      <View style={{ marginBottom: 95 }} />    </>  );};export default Feed;